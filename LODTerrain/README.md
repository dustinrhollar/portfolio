# TerrainEngine

## About

TerrainEngine is a small rendering program that uses OpenGL to render large scale terrain procedurally. 

In its current state, terrain is generated by using the OpenSimplex Noise algorithm. Optionally, a user can toggle three Erosion Algorithms (Thermal, Hydraulic, and InverseThermal) to further tweak the generated terrain.

A second demo is provided that uses geometric clipmapping. After a heightmap is generated, a portion of the terrain mesh is computed. I have dubbed this portion of the mesh a "pizza slice" since it represents a 22.5 degree arc within a scquare grid.

[[https://github.com/dustinrhollar/portfolio/blob/main/LODTerrain/showcase/gen_terrain.png|Procedural Terrain]]

This pizza slice is rotated and moved about to render the entire terrain. Only a small portion of the mesh is computed for two reasons:
1. Reduces the amount of geometry that has to be stored on the GPU
2. Make it easier for CPU side clipping

The mesh is then tesselated on the GPU and smoothed using bicubic interpolation.

[Image of smoothed terrain]

## Compiling

In its current state, TerrainEngine only has support for Linux systems. This is because I mainly work on Linux and haven't ported the program to Windows. It should be trivial to port the project to Mac by adjusting the Libs variable in the Makefile.

This project uses Make as its build system and has several useful commands for building.

After cloning, cd into the directory.

```
make prep
make build_deps
make
make run
make clean
```

Creating the build directory only needs to be done after cloning. The command *build_deps* builds any dependency projects. Currently, it builds ImGui into a shared lib. 

*make* does two things: Preps the build directory. Builds the project for *release*. 

*make run* runs the program for release.

*make clean* cleans the build directory of build files, libraries, and executables. Note that after a *make clean* call, the user must run either *make* or *make prep* before running agin.

To see the full list of make commands, please see the Makefile in the top level directory.

## Usage

The app is designed so that a user only needs to edit values within `main.cpp`. To adjust terrain generation, edit the struct `SimplexNoise::NoiseOctaveSimulation`. A sample struct is filled out below.
```
SimplexNoise::NoiseOctaveSimulation noiseSim;
noiseSim.width         = textureWidth;             // Width of the texture
noiseSim.height        = textureHeight;            // Height of the texture
noiseSim.numOctaves    = 8;                        // Control the number of octaves used
noiseSim.persistence   = 0.50f;                    // Control the roughness of the output
noiseSim.low           = 0.00f;                    // Low output value
noiseSim.high          = 1.00f;                    // Height output value
noiseSim.exp           = 2.00f;                    // Controls the intensity of black to white
noiseSim.dim           = noiseSim.TWODIMENSION;    // Define the dimension of noise
```

To swap the demo that is running, a user can swap between the LODApp and TerrainApp that is defined within `main.cpp`. The LODApp has a severak compile time settings that can be adjusted within `LODApp.cpp`:
1. Clipping         - whether or not the "pizza slices" are clipped
2. Tesselation      - toggle the tesselation shaders
3. Movement         - simulates a rolling terrain separate from the camera
4. Secondary Camera - a second camera so that user can observe the tesselation independently


## Dependencies

I try to keep the depedencies as limited as possible, but there places where it is necessary to externel libraries.

### GLFW and OpenGL

This project uses OpenGL for its Graphics API. In the future, I might move to supporting Vulkan or DirectX, but that will be after I fully set up the renderer in OpenGL.

Assuming you are building this project on Linux, OpenGL should be installed with your distro. If not, you will need to check your distro's wiki pages or package manager for more information.

*GLFW* is a multiplatofrm library for various Graphics API. It makes inital development much easier by abstracted a lot of the more tedious aspects of Platform API. Some Linux distributions come with GLFW installed, so check your package manager to determine if it is installed. If not, you can either build from source or download from your package manager. If you choose the latter approach, you might have to check the name of the installed library. I have found that sometimes GLFW will be installed as libglfw or libglfw3. If you recieve a build error for GLFW this might be the case. Go to the Lib variable in the Makefile and adjust the name of the GLFW library as needed.

If compiling from source, follow these steps:

After unzipping the GLFW source, cd into the directory. Note that compiling GLFW from source requires CMake.
```
cmake -DBUILDSHARED_LIBS=ON -G"Unix Makefiles"
make
make install
```
If root privilages are required, add *sudo* before the command.

Pay close attention to where Make installed the headers and binaries. If they were installed to */usr/local/lib64*, you will have to do some extra work. */usr/local/lib64* is not in your PATH variable by default, so you will want to temporarily or permanently add this to your PATH. I add it to my PATH permanently in order to avoid having to adjust my *.bashrc* file.

First open a file called local_lib.conf in the following directory. I use *vim*, but if you are not familiar with *vim*, I'd suggest using *nano* or a text editor of your choice.
```
sudo vim /etc/ld.so.conf.d/local_lib.conf
```

Enter the line
```
/usr/local/lib64
```

Save and close the file. Go back to your terminal and run the command
```
sudo ldconfig
```

The directory */usr/local/lib64* should now be apart of your path along with GLFW.

### GLM

GLM is a widely used math for Graphics applications and is the one I am currently using. I will probably be phasing it out in the future in favor of a lighter weight library. 

### STB

STB is a collection of header-only files that are very useful. I currently use two of them: *stb_image.h* (loading image files) and *stb_ds.h* (dynamic arrays + hash tables).

### ImGui
The Engine uses ImGui as its GUI. ImGui is an intuitive, immediate mode GUI library that has been easy to integrated into the project and used. The library is currently compiled as a static library and linked at compile time in order to reduce
